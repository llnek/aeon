#include <iostream>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <vector>
#include <map>
#include <set>
#include <string>
#include <stdexcept>

#include "test.h"

enum {
  T_PROCEDURE,
  T_PROGRAM,
  T_VAR,
  T_REAL,
  T_INT,
  T_INT_DIV,
  T_INTEGER,
  T_FLOAT,
  T_MULT,
  T_DIV,
  T_PLUS,
  T_MINUS,
  T_LPAREN,
  T_RPAREN,
  T_LBRACE,
  T_RBRACE,
  T_BEGIN,
  T_ID,
  T_END,
  T_COLON,
  T_ASSIGN,
  T_SEMI,
  T_DOT,
  T_COMMA,
  T_EOF
};

std::map<int, std::string> I_TOKENS {
  {T_PROCEDURE, "PROCEDURE"},
  {T_PROGRAM, "PROGRAM"},
  {T_VAR, "VAR"},
  {T_REAL, "REAL"},
  {T_INT, "INTEGER"},
  {T_INT_DIV, "DIV"},
  {T_INTEGER,"integer"},
  {T_FLOAT,"float"},
  {T_MULT,"*"},
  {T_COLON,":"},
  {T_DIV,"/"},
  {T_PLUS, "+"},
  {T_MINUS, "-"},
  {T_LPAREN,"("},
  {T_RPAREN,")"},
  {T_LBRACE,"{"},
  {T_RBRACE,"}"},
  {T_BEGIN, "BEGIN"},
  {T_ASSIGN, ":="},
  {T_SEMI,";"},
  {T_DOT,"."},
  {T_COMMA, ","},
  {T_END, "END"},
  {T_EOF, "EOF"}
};

enum Reserved {
  Keyword, Opcode
};

enum {
  INT_VALUE, FLOAT_VALUE, NULL_VALUE
};

struct DataValue {
  DataValue(int t, long v) {
    type=t;
    value.num=v;
  }
  DataValue(int t, double v) {
    type=t;
    value.real=v;
  }
  DataValue() {
    type=NULL_VALUE;
  }
  int type;
  union {
    long num;
    double real;
  } value;
};


std::map<std::string,DataValue> GLOBAL_SCOPE;
SymbolTable SYM_TABLE;


std::map<std::string,int> KEYWORDS {
  {I_TOKENS.find(T_BEGIN)->second, T_BEGIN},
  {I_TOKENS.find(T_END)->second, T_END},
  {I_TOKENS.find(T_ASSIGN)->second, T_ASSIGN},
  {I_TOKENS.find(T_SEMI)->second, T_SEMI},
  {I_TOKENS.find(T_DOT)->second, T_DOT},
  {I_TOKENS.find(T_COLON)->second, T_COLON},
  {I_TOKENS.find(T_COMMA)->second, T_COMMA},
  {I_TOKENS.find(T_PROGRAM)->second, T_PROGRAM},
  {I_TOKENS.find(T_PROCEDURE)->second, T_PROCEDURE},
  {I_TOKENS.find(T_VAR)->second, T_VAR},
  {I_TOKENS.find(T_INT)->second, T_INT},
  {I_TOKENS.find(T_REAL)->second, T_REAL},
  {I_TOKENS.find(T_INT_DIV)->second, T_INT_DIV}
};

struct Token {
  Token(int type) {
    this->token=type;
    if (type == T_ID) {
    } else {
      ::printf("token=%s\n", I_TOKENS[type].c_str());
    }
  }
  Token(int type, const std::string& s) : Token(type) {
    ::strcpy(this->value.name, s.c_str());
    if (type == T_ID) {
      ::printf("var=%s\n", s.c_str());
    }
  }
  Token(Reserved type, int t) : Token(t) {
    ::strcpy(this->value.name, I_TOKENS.find(t)->second.c_str());
  }
  Token(int type, long n) : Token(type) {
    this->value.num=n;
  }
  Token(int type, double d) : Token(type) {
    this->value.real=d;
  }
  Token(int type, const char c) : Token(type) {
    this->value.name[0]=c;
    this->value.name[1]='\0';
  }
  /*
  Token(int type, const char* s) : Token(type) {
    ::strcpy(this->value.name, s);
  }*/
  int token;
  union {
    double real;
    long num;
    char name[512];
  } value;
};

struct Context {
  const char* src;
  size_t len;
  int pos;
  bool eof;
  Token* cur;
};

struct Ast {
  Ast(Token* t) : token(t) {}
  Ast() {}
  virtual ~Ast() {}
  virtual DataValue visit() = 0;
  Token* token;
};

struct BinOp : public Ast {
  BinOp(Ast* left, Token* op, Ast* right) : Ast(op) {
    this->left = left;
    this->right = right;
  }
  ~BinOp() {}
  DataValue visit() {
    DataValue lf, rt;
    double x, y, z;

    switch (this->token->token) {
      case T_MINUS:
        lf= left->visit();
        rt= right->visit();
        if (lf.type == T_INT)  {
          x= (double) lf.value.num ;
        } else { x= lf.value.real; }
        if (rt.type == T_INT)  {
          y= (double) rt.value.num ;
        } else { y= rt.value.real; }
        z = x - y;
        if (lf.type == T_REAL || rt.type==T_REAL) {
          return DataValue(T_REAL, z);
        } else {
          return DataValue(T_INT,(long) z);
        }
        break;

      case T_PLUS:
        lf= left->visit();
        rt= right->visit();
        if (lf.type == T_INT)  {
          x= (double) lf.value.num ;
        } else { x= lf.value.real; }
        if (rt.type == T_INT)  {
          y= (double) rt.value.num ;
        } else { y= rt.value.real; }
        z = x + y;
        if (lf.type == T_REAL || rt.type==T_REAL) {
          return DataValue(T_REAL, z);
        } else {
          return DataValue(T_INT,(long) z);
        }
        break;

      case T_MULT:
        lf= left->visit();
        rt= right->visit();
        if (lf.type == T_INT)  {
          x= (double) lf.value.num ;
        } else { x= lf.value.real; }
        if (rt.type == T_INT)  {
          y= (double) rt.value.num ;
        } else { y= rt.value.real; }
        z = x * y;
        if (lf.type == T_REAL || rt.type==T_REAL) {
          return DataValue(T_REAL, z);
        } else {
          return DataValue(T_INT,(long) z);
        }
        break;

      case T_DIV:

        lf= left->visit();
        rt= right->visit();
        if (lf.type == T_INT)  {
          x= (double) lf.value.num ;
        } else { x= lf.value.real; }
        if (rt.type == T_INT)  {
          y= (double) rt.value.num ;
        } else { y= rt.value.real; }
        z = x / y;
        return DataValue(T_REAL, z);
        break;
      case T_INT_DIV:
        lf= left->visit();
        rt= right->visit();
        if (lf.type == T_INT)  {
          x= (double) lf.value.num ;
        } else { x= lf.value.real; }
        if (rt.type == T_INT)  {
          y= (double) rt.value.num ;
        } else { y= rt.value.real; }
        z = x / y;
        return DataValue(T_INT,(long) z);
        break;

    }
    return DataValue();
  }
  Ast* left;
  Ast* right;
};

struct Num : public Ast {
  Num(Token* t) : Ast(t) {
  }
  DataValue visit() {
    switch (token->token) {
      case T_INTEGER:
        return DataValue(T_INT, token->value.num);
      case T_FLOAT:
      return DataValue(T_REAL, token->value.real);
    }
    return DataValue();
  }
};

struct UnaryOp : public Ast {
  UnaryOp(Token* t, Ast* expr) : Ast(t) {
    this->expr=expr;
  }
  ~UnaryOp() {}
  DataValue visit() {
    switch (this->token->token) {
      case T_PLUS:
        return expr->visit();
      case T_MINUS:
        auto x= expr->visit();
        if (x.type == T_INT)
          return DataValue(x.type, - x.value.num);
        if (x.type == T_REAL)
          return DataValue(x.type, - x.value.real);
    }
    return DataValue();
  }

  Ast* expr;
};

struct Compound : public Ast {
  Compound() {
  }
  ~Compound() {}
  DataValue visit() {
    for (auto it = children.begin(); it != children.end(); ++it) {
      (*it)->visit();
    }
    return DataValue();
  }
  std::vector<Ast*> children;
};

struct Assignment : public Ast {
  Assignment(Ast* left, Token* op, Ast* right) : Ast(op) {
    this->left=left;
    this->right=right;
  }
  ~Assignment() {}
  DataValue visit() {
    auto var_name = left->token->value.name;
    auto var_symbol = SYM_TABLE.lookup(var_name);
    if (! var_symbol) {
      throw new std::runtime_error("bad symbol");
    }

    ::printf("Assigning value to %s\n", var_name);
    GLOBAL_SCOPE[var_name] = right->visit();
    return DataValue();
  }
  Ast* left;
  Ast* right;
};

struct NoOp : public Ast {
  NoOp() {}
  ~NoOp() {}
  DataValue visit() {
    return DataValue();
  }
};

struct Var : public Ast {
  Var(Token* t) : Ast(t) {}
  ~Var() {}
  DataValue visit() {
    std::string name(token->value.name);
    auto s = SYM_TABLE.lookup(name.c_str());
    if (! s) {
      throw new std::runtime_error("Name error ");
    }
    auto x= GLOBAL_SCOPE.find(name);
    if (x != GLOBAL_SCOPE.end()) {
      return x->second;
    }
    return DataValue();
  }
};

struct Type : public Ast {
  Type(Token* token) : Ast(token) {
  }
  ~Type() {}
  DataValue visit() {
    return DataValue();
  }
};


SymbolTable::SymbolTable() { init(); }
void SymbolTable::init() {
  define(new BuiltinTypeSymbol("INTEGER"));
  define(new BuiltinTypeSymbol("REAL"));
}
void SymbolTable::define(Symbol* s) {
  ::printf("Define: %s\n", s->name.c_str());
  symbols[s->name] = s;
}
Symbol* SymbolTable::lookup(const char* name) {
  ::printf("Lookup: %s\n", name);
  auto x = symbols.find(name);
  if (x != symbols.end()) {
    return x->second;
  }
  return nullptr;
}


struct VarDecl : public Ast {
  VarDecl(Ast* var_node, Ast* type_node) {
    this->var_node = var_node;
    this->type_node = type_node;
  }
  ~VarDecl() {}
  DataValue visit() {
    auto type_name = type_node->token->value.name;
    auto type_symbol = SYM_TABLE.lookup(type_name);
    auto var_name = var_node->token->value.name;
    auto var_symbol = new VarSymbol(var_name, type_symbol);
    SYM_TABLE.define(var_symbol);
    return DataValue();
  }
  Ast* var_node;
  Ast* type_node;
};

struct Block : public Ast {
  Block(std::vector<Ast*> &decls, Ast* compound_statement) {
    declarations.insert(declarations.begin(), decls.begin(), decls.end());
    this->compound_statement = compound_statement;
  }
  ~Block() {}
  DataValue visit() {
    for (auto& x : declarations) {
      x->visit();
    }
    return compound_statement->visit();
  }
  std::vector<Ast*> declarations;
  Ast* compound_statement;
};

struct ProcedureDecl : public Ast {
  ProcedureDecl(const char *proc_name, Ast* block_node) {
    this->name = proc_name;
    this->block = block_node;
  }
  DataValue visit() {
    return DataValue();
  }
  std::string name;
  Ast* block;
};

struct Program : public Ast {
  Program(const char* name, Ast* block) {
    this->name = name;
    this->block = block;
  }
  ~Program() {}
  DataValue visit() {
    return block->visit();
  }
  std::string name;
  Ast* block;
};



Ast* compound_statement(Context&);
Ast* block(Context&);
Ast* variable(Context&);
Ast* expr(Context&);
Token* eat(int,Context&);

Token* error(Context &ctx) {

  std::string s= "Error parsing input, pos= ";
  s += ctx.pos;

  throw new std::runtime_error(s);
}

void advance(Context &ctx) {
  ++ctx.pos;
  if (ctx.pos >= ctx.len) {
    ctx.eof=true;
  }
}

void skip_comment(Context &ctx) {
  while (!ctx.eof) {
    if (ctx.src[ctx.pos] != '}') {
      advance(ctx);
    } else {
      advance(ctx);
      break;
    }
  }
}

void skip(Context &ctx) {
  while (!ctx.eof &&
         isspace(ctx.src[ctx.pos]))  advance(ctx);
}


Token* _id(Context &ctx) {
  std::string res;
  char ch;
  while (!ctx.eof) {
    ch=ctx.src[ctx.pos];
    if (res.empty()) {
      if (ch== '_' || ::isalpha(ch)) {
        res.push_back(ch);
        advance(ctx);
      } else {
        break;
        //error(ctx);
      }
    } else {
      if (ch== '_' || ::isalpha(ch) || ::isdigit(ch)) {
        res.push_back(ch);
        advance(ctx);
      } else {
        break;
        //error(ctx);
      }
    }
  }
  auto it= KEYWORDS.find(res);
  Token* t;
  if (it != KEYWORDS.end()) {
    t= new Token(Keyword,it->second);
  } else {
    t= new Token(T_ID,res);
  }

  return t;
}

std::string digits(Context &ctx) {
  std::string res;
  while (!ctx.eof && ::isdigit(ctx.src[ctx.pos])) {
    res.push_back(ctx.src[ctx.pos]);
    advance(ctx);
  }
  return res;
}

Token* number(Context &ctx) {
  std::string res = digits(ctx);
  Token* t;

  if (!ctx.eof && ctx.src[ctx.pos] == '.') {
    res.push_back(ctx.src[ctx.pos]);
    advance(ctx);
    res.append(digits(ctx));
    t = new Token(T_FLOAT, std::stod(res));
  } else {
    t = new Token(T_INTEGER, std::stol(res));
  }

  return t;
}

char peek(Context &ctx) {
  auto nx = ctx.pos + 1;
  if (nx >= ctx.len) {
    return '\0';
  }
  return ctx.src[nx];
}

Token* get_next_token(Context &ctx) {
  char ch;
  while (!ctx.eof) {
    ch= ctx.src[ctx.pos];
    if (::isspace(ch)) {
      skip(ctx);
    }
    else
    if (::isdigit(ch)) {
      return number(ctx);
    }
    else
    if (ch == '*') {
      advance(ctx);
      return new Token(T_MULT, '*');
    }
    else
    if (ch == '/') {
      advance(ctx);
      return new Token(T_DIV, '/');
    }
    else
    if (ch == '+') {
      advance(ctx);
      return new Token(T_PLUS, '+');
    }
    else
    if (ch == '-') {
      advance(ctx);
      return new Token(T_MINUS, '-');
    }
    else
    if (ch == '(') {
      advance(ctx);
      return new Token(T_LPAREN, '(');
    }
    else
    if (ch == ')') {
      advance(ctx);
      return new Token(T_RPAREN, ')');
    }
    else
    if (ch == '_' || ::isalpha(ch)) {
      return _id(ctx);
    }
    else
    if (ch== ':' && '=' == peek(ctx)) {
      advance(ctx);
      advance(ctx);
      return new Token(Opcode, T_ASSIGN);
    }
    else
    if (ch == '{') {
      advance(ctx);
      skip_comment(ctx);
    }
    else
    if (ch == '}') {
      advance(ctx);
      return new Token(Opcode, T_RBRACE);
    }
    else
    if (ch == ';') {
      advance(ctx);
      return new Token(Opcode, T_SEMI);
    }
    else
    if (ch == ':') {
      advance(ctx);
      return new Token(Opcode, T_COLON);
    }
    else
    if (ch == ',') {
      advance(ctx);
      return new Token(Opcode, T_COMMA);
    }
    else
    if (ch == '.') {
      advance(ctx);
      return new Token(Opcode, T_DOT);
    }
    else {
      return error(ctx);
    }
  }

  return new Token(T_EOF);
}


void lexer(const char* src) {
}

Token* eat(int want, Context &ctx) {
  auto t= ctx.cur;
  if (t && t->token == want) {
    ctx.cur= get_next_token(ctx);
    return t;
  }
  return error(ctx);
}

void init(Context &ctx) {
  auto t= get_next_token(ctx);
  ctx.eof=false;
  ctx.cur=t;
}

Ast* factor(Context &ctx) {
  auto t= ctx.cur;
  Ast* res=nullptr;
  switch (t->token) {
    case T_PLUS:
      eat(T_PLUS,ctx);
      res = new UnaryOp(t, factor(ctx));
      break;
    case T_MINUS:
      eat(T_MINUS,ctx);
      res = new UnaryOp(t, factor(ctx));
      break;
    case T_INTEGER:
      eat(T_INTEGER,ctx);
      res= new Num(t);
      break;
    case T_FLOAT:
      eat(T_FLOAT,ctx);
      res= new Num(t);
      break;
    case T_LPAREN:
      eat(T_LPAREN,ctx);
      res= expr(ctx);
      eat(T_RPAREN,ctx);
      break;
    default:
      res= variable(ctx);
      break;
  }
  return res;
}

Ast* term(Context &ctx) {
  static std::set<int> ops {T_MULT,T_DIV, T_INT_DIV};
  auto res= factor(ctx);
  Token* op;
  while (ops.find(ctx.cur->token) != ops.end()) {
    op= ctx.cur;
    switch (op->token) {
      case T_MULT:
        eat(T_MULT,ctx);
      break;
      case T_DIV:
        eat(T_DIV,ctx);
      break;
      case T_INT_DIV:
        eat(T_INT_DIV,ctx);
      break;
    }
    res = new BinOp(res, op, factor(ctx));
  }
  return res;
}

Ast* expr(Context &ctx) {
  static std::set<int> ops {T_PLUS,T_MINUS};
  Ast* res= term(ctx);
  Token* op;
  while (ops.find(ctx.cur->token) != ops.end()) {
    op= ctx.cur;
    switch (op->token) {
      case T_PLUS:
        eat(T_PLUS,ctx);
      break;
      case T_MINUS:
        eat(T_MINUS,ctx);
      break;
    }
    res= new BinOp(res, op, term(ctx));
  }

  return res;
}

Ast* type_spec(Context& ctx) {
  auto token = ctx.cur;
  if (token->token == T_INT)
    eat(T_INT,ctx);
  else
    eat(T_REAL,ctx);
  return new Type(token);
}

std::vector<Ast*> variable_declaration(Context &ctx) {
  std::vector<Ast*> vars { new Var(ctx.cur) };
  eat(T_ID,ctx);
  while (ctx.cur->token == T_COMMA) {
    eat(T_COMMA,ctx);
    vars.push_back(new Var(ctx.cur));
    eat(T_ID,ctx);
  }
  eat(T_COLON,ctx);

  auto type = type_spec(ctx);
  std::vector<Ast*> out;
  for (auto &x : vars) {
    out.push_back(new VarDecl(x, type));
  }
  return out;
}

Ast* variable(Context& ctx) {
  auto node = new Var(ctx.cur);
  eat(T_ID,ctx);
  return node;
}

std::vector<Ast*> declarations(Context &ctx) {
  std::vector<Ast*> ds;

  if (ctx.cur->token == T_VAR) {
    eat(T_VAR, ctx);
    while (ctx.cur->token == T_ID) {
      auto vs = variable_declaration(ctx);
      ds.insert(ds.end(),vs.begin(),vs.end());
      eat(T_SEMI,ctx);
    }
  }

  while (ctx.cur->token == T_PROCEDURE) {
    eat(T_PROCEDURE, ctx);
    auto proc_name = ctx.cur->value.name;
    eat(T_ID,ctx);
    eat(T_SEMI, ctx);
    auto block_node = block(ctx);
    auto proc = new ProcedureDecl(proc_name, block_node);
    ds.push_back(proc);
    eat(T_SEMI,ctx);
  }

  return ds;
}

Ast* block(Context &ctx) {
  auto decls = declarations(ctx);
  auto cs = compound_statement(ctx);
  return new Block(decls, cs);
}

Ast* assignment_statement(Context& ctx) {
  auto left = variable(ctx);
  auto t = ctx.cur;
  eat(T_ASSIGN,ctx);
  auto right = expr(ctx);
  return new Assignment(left, t, right);
}


Ast* empty(Context& ctx) {
  return new NoOp();
}

Ast* statement(Context &ctx) {
  Ast* node;
  switch (ctx.cur->token) {
    case T_BEGIN:
      node = compound_statement(ctx);
      break;
    case T_ID:
      node = assignment_statement(ctx);
      break;
    default:
      node = empty(ctx);
      break;
  }
  return node;
}

std::vector<Ast*> statement_list(Context &ctx) {

  std::vector<Ast*> results {
    statement(ctx)
  };

  while (ctx.cur->token == T_SEMI) {
    eat(T_SEMI, ctx);
    results.push_back(statement(ctx));
  }

  if (ctx.cur->token == T_ID) {
    error(ctx);
  }

  return results;
}

Ast* compound_statement(Context &ctx) {
  eat(T_BEGIN,ctx);
  auto nodes = statement_list(ctx);
  eat(T_END, ctx);
  auto root= new Compound();
  for (auto& node : nodes) {
    root->children.push_back(node);
  }
  return root;
}

Ast* program(Context &ctx) {
  eat(T_PROGRAM,ctx);

  auto var_node = variable(ctx);
  auto prog_name = var_node->token->value.name;

  eat(T_SEMI,ctx);

  auto block_node = block(ctx);
  auto program_node = new Program(prog_name, block_node);

  eat(T_DOT,ctx);

  return program_node;
}




Ast* parse(const char* src) {

  Context ctx { src, ::strlen(src), 0, false, nullptr};
  init(ctx);

  auto res= program(ctx);
  return res;
}

const char* XARG="BEGIN\n\
\n\
BEGIN\n\
        number := 2;\n\
  a := number;\n\
         b := 10 * a + 10 * number / 4;\n\
         c := a - - b\n\
     END;\n\
\n\
     x := 11;\n\
 END.\n";

const char* XXARG="\n\
PROGRAM Part10AST;\n\
VAR\n\
  number: INTEGER;\n\
   a, b : INTEGER;\n\
   y    : REAL;\n\
\n\
BEGIN {Part10AST}\n\
   number := 2;\n\
   a := number;\n\
   b := 10 * a + 10 * a DIV 4;\n\
   y := 20 / 7 + 3.14;\n\
END.  {Part10AST}\n\
";

const char* ARG = "\n\
PROGRAM Part12;\n\
VAR\n\
   a : INTEGER;\n\
\n\
PROCEDURE P1;\n\
VAR\n\
   a : REAL;\n\
   k : INTEGER;\n\
\n\
   PROCEDURE P2;\n\
   VAR\n\
      a, z : INTEGER;\n\
   BEGIN {P2}\n\
      z := 777;\n\
   END;  {P2}\n\
\n\
BEGIN {P1}\n\
\n\
END;  {P1}\n\
\n\
BEGIN {Part12}\n\
   a := 10;\n\
END.  {Part12}\n\
";



int main(int argc, char* argv[]) {
  try {
    auto tree= parse(ARG);//"5 - - - + - (3 + 4) - +2");//" 2 + ((5 + 4) * 3)");
    auto res= tree->visit();
    if (res.type == T_INT)
      ::printf("result = %ld\n\n", res.value.num);
    else
      ::printf("result = %lf\n\n", res.value.real);

    for (auto it= GLOBAL_SCOPE.begin(); it != GLOBAL_SCOPE.end(); ++it) {
      auto x = it->second;
      if (x.type == T_INT)
        ::printf("key = %s, value = %ld\n", it->first.c_str(), x.value.num);
      if (x.type == T_REAL)
        ::printf("key = %s, value = %lf\n", it->first.c_str(), x.value.real);
    }

  } catch (std::exception& e) {
    ::printf("%s", e.what());
  }
  return 0;
}
