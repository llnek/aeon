#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <vector>
#include <map>
#include <string>

static const char *program ="\
10 gosub 100\n\
20 for i = 1 to 10\n\
30 print i\n\
40 next i\n\
50 print \"e\tn\nd\"\n\
60 end\n\
100 print \"subroutine\"\n\
110 return\n";

enum {
  T_KEYWORD,
  T_SYMBOL,
  T_LPAREN,
  T_RPAREN,
  T_LBRACKET,
  T_RBRACKET,
  T_LBRACE,
  T_RBRACE,
  T_PLUS,
  T_MINUS,
  T_STAR,
  T_SLASH,
  T_PERC,
  T_EQUALS,
  T_BANG,
  T_TILDA,
  T_LT,
  T_GT,
  T_LTEQ,
  T_GTEQ,
  T_DOT,
  T_SEMI,
  T_VAR,
  T_STRING,
  T_LONG,
  T_DOUBLE,
  T_LEXEME
};

std::map<std::string,int> XXX {
  {"(",T_LPAREN},
  {")",T_RPAREN},
  {"[",T_LBRACKET},
  {"]",T_RBRACKET},
  {"{",T_LBRACE},
  {"}",T_RBRACE},
  {"+",T_PLUS},
  {"-",T_MINUS},
  {"*",T_STAR},
  {"/",T_SLASH},
  {"%",T_PERC},
  {"=",T_EQUALS},
  {"!",T_BANG},
  {"~",T_TILDA},
  {"<",T_LT},
  {">",T_GT},
  {"<=", T_LTEQ},
  {">=",T_GTEQ},
  {".",T_DOT},
  {";",T_SEMI}
};
struct Token {
  Token(int type, int line, int col) {
    this->token=type;
    this->line=line;
    this->col=col;
  }
  ~Token() {
    if (this->token==T_STRING) {
      delete[] this->value.str;
    }
  }
  const std::string toString() {
    switch (token) {
      case T_STRING:
        return std::string(this->value.str);
      case T_LONG:
        return std::to_string(this->value.i_num);
      case T_DOUBLE:
        return std::to_string(this->value.d_num);
      case T_VAR:
        return std::string(this->value.name);
      default:
        return std::string(this->value.name);
    }
  }
  int line;
  int col;
  int token;
  union {
    char* str;
    int i_num;
    double d_num;
    char name[256];
  } value;
};

bool isDouble(const char* s) {
  int dot=0;
  while (*s) {
    if (*s == '.') {
      if (dot == 0) { ++dot; }
      else break;
    }
    else
    if (!::isdigit(*s))
    break;
    ++s;
  }
  return *s == '\0';
}

bool isLong(const char* s) {
  while (*s) {
    if (!::isdigit(*s))
    break;
    ++s;
  }
  return *s == '\0';
}

bool isVar(const char* s) {
  return ::isalpha(*s) || (*s == '_');
}

void token(std::vector<Token*> &tree, std::string &text, int type, int line, int col) {
  Token* t=new Token(type,line,col);
  const char* str = text.c_str();
  int len= ::strlen(str);

  switch (type) {
    case T_LEXEME:
      if (isLong(str)) {
        long n=0;
        ::sscanf(str,"%ld", &n);
        t->token=T_LONG;
        t->value.i_num=n;
      } else if (isDouble(str)) {
        double n=0.0;
        ::sscanf(str,"%lf", &n);
        t->token=T_DOUBLE;
        t->value.d_num=n;
      } else if (isVar(str)) {
        assert(::strlen(str) < 256);
        t->token=T_VAR;
        ::strcpy(t->value.name, str);
      }
    break;
    case T_STRING:
      t->value.str=new char[len];
      ::strcpy(t->value.str, str);
    break;
    case T_SYMBOL:
      auto it=XXX.find(text);
      assert(it != XXX.end());
      t->token= it->second;
      ::strcpy(t->value.name, str);
    break;
  }

  text.clear();
  tree.push_back(t);
}

bool isSymbol(const char ch) {
  switch (ch) {
    case '[': case ']':
    case '(': case ')':
    case '+': case '-':
    case '*': case '/':
    case ';': case ',':
    case '~': case '=':
      return true;
    break;
  }
  return false;
}

std::vector<Token*> lexer(const char* src, const char* fname) {
  auto len = ::strlen(src);
  auto commentQ = 0;
  auto escQ = 0;
  auto strQ = 0;
  auto line = 1;
  char ch;
  char nx;
  auto col = 0;
  auto pos = 0;
  auto tcol = col;
  auto tline = line;

  std::vector<Token*> tree;
  std::string lexeme;

  while (pos < len) {
    ch = src[pos];
    ++col;
    ++pos;

    if (ch == '\n') {
      col = 0;
      ++line;
      if (commentQ) {
        commentQ= 0;
      }
    }

    if (commentQ) {
    }
    else
    if (escQ) {
      lexeme.push_back(ch);
      escQ=0;
    }
    else
    if (ch == '\"') {
      if (!strQ) {
        tline = line;
        tcol = col;
        strQ= 1;
        assert(lexeme.empty());
      } else {
        strQ=0; //end of string
        token(tree,lexeme, T_STRING,tline,tcol);
      }
    }
    else
    if (strQ) {
      lexeme.push_back(ch);
    }
    else
    if (isSymbol(ch)) {
      assert(lexeme.empty());
      lexeme.push_back(ch);
      if ((ch== '>' || ch == '<') && (pos+1) < len) {
        nx= src[pos+1];
        if (nx == '=') {
          lexeme.push_back(nx);
          ++pos;
        }
      }
      token(tree,lexeme, T_SYMBOL,tline,tcol);
    }
    else
    if (::isspace(ch)) {
      if (!lexeme.empty()) {
        token(tree,lexeme, T_LEXEME,tline,tcol);
      }
    }
    else {
      //identifier
      if (lexeme.empty()) { //new token
        tcol = col;
        tline = line;
      }
      lexeme.push_back(ch);
    }
  }

  return tree;
}

int main(int argc, char* argv[]) {
	auto v= lexer(program,"");
  for(auto it=v.begin(); it != v.end(); it++) {
    auto x= *it;
	  ::printf("%s\n",x->toString().c_str());
  }
	return 0;
}
